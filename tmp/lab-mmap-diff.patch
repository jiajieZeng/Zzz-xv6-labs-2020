diff --git a/Makefile b/Makefile
index d8509b1..93ba80e 100644
--- a/Makefile
+++ b/Makefile
@@ -175,7 +175,7 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
-
+	$U/_mmaptest\
 
 
 
diff --git a/kernel/defs.h b/kernel/defs.h
index 41098f4..91c72e3 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -8,7 +8,7 @@ struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
-
+struct vma;
 // bio.c
 void            binit(void);
 struct buf*     bread(uint, uint);
@@ -33,7 +33,9 @@ void            fileinit(void);
 int             fileread(struct file*, uint64, int n);
 int             filestat(struct file*, uint64 addr);
 int             filewrite(struct file*, uint64, int n);
-
+int             lazyallocation(uint64);
+pte_t*          walk(pagetable_t, uint64, int);
+int             fileuvmunmap(pagetable_t, uint64, uint64, struct vma*);
 // fs.c
 void            fsinit(int);
 int             dirlink(struct inode*, char*, uint);
diff --git a/kernel/param.h b/kernel/param.h
index b5fdcb2..a54edc2 100644
--- a/kernel/param.h
+++ b/kernel/param.h
@@ -11,3 +11,4 @@
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
 #define FSSIZE       1000  // size of file system in blocks
 #define MAXPATH      128   // maximum file path name
+#define NVMA         16    // vma size
diff --git a/kernel/proc.c b/kernel/proc.c
index ba1a9e3..9df3ed2 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -146,6 +146,9 @@ freeproc(struct proc *p)
   if(p->trapframe)
     kfree((void*)p->trapframe);
   p->trapframe = 0;
+  for (int i = 0; i < NVMA; i++) {
+    fileuvmunmap(p->pagetable, p->vmaslot[i].begin, p->vmaslot[i].length, &p->vmaslot[i]);
+  }
   if(p->pagetable)
     proc_freepagetable(p->pagetable, p->sz);
   p->pagetable = 0;
@@ -296,6 +299,13 @@ fork(void)
       np->ofile[i] = filedup(p->ofile[i]);
   np->cwd = idup(p->cwd);
 
+  for(i = 0; i < NVMA; i++) {
+    np->vmaslot[i] = p->vmaslot[i];
+    if (np->vmaslot[i].mapped) {
+        filedup(np->vmaslot[i].f);
+    }
+  }
+
   safestrcpy(np->name, p->name, sizeof(p->name));
 
   pid = np->pid;
diff --git a/kernel/proc.h b/kernel/proc.h
index 9c16ea7..c63c566 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -80,6 +80,18 @@ struct trapframe {
   /* 280 */ uint64 t6;
 };
 
+
+struct vma {
+    uint64 begin;
+    uint64 length;
+    int prot;
+    int flags;
+    struct file* f;
+    uint64 offset;
+    int mapped; 
+};
+
+
 enum procstate { UNUSED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
 
 // Per-process state
@@ -103,4 +115,6 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  struct vma vmaslot[NVMA];            // what mmap has mapped for each process
 };
+
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 0aec003..96f7940 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -331,6 +331,7 @@ sfence_vma()
 #define PTE_W (1L << 2)
 #define PTE_X (1L << 3)
 #define PTE_U (1L << 4) // 1 -> user can access
+#define PTE_D (1L << 7)
 
 // shift a physical address to the right place for a PTE.
 #define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
diff --git a/kernel/syscall.c b/kernel/syscall.c
index c1b3670..7320633 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -104,6 +104,8 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_wait(void);
 extern uint64 sys_write(void);
 extern uint64 sys_uptime(void);
+extern uint64 sys_mmap(void);
+extern uint64 sys_munmap(void);
 
 static uint64 (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -127,6 +129,8 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_mmap]    sys_mmap,
+[SYS_munmap]  sys_munmap,
 };
 
 void
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..e7b18d6 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,5 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_mmap   22
+#define SYS_munmap 23
diff --git a/kernel/sysfile.c b/kernel/sysfile.c
index 5dc453b..658aea0 100644
--- a/kernel/sysfile.c
+++ b/kernel/sysfile.c
@@ -15,6 +15,7 @@
 #include "sleeplock.h"
 #include "file.h"
 #include "fcntl.h"
+#include "memlayout.h"
 
 // Fetch the nth word-sized system call argument as a file descriptor
 // and return both the descriptor and the corresponding struct file.
@@ -78,6 +79,188 @@ sys_read(void)
   return fileread(f, p, n);
 }
 
+
+int                                                                                             
+lazyallocation(uint64 va)
+{   
+    struct proc *p = myproc();
+    struct vma *vma;
+    struct file *fptr;
+    struct inode *iptr;
+    int found = 0;
+    char *mem; 
+    for (int i = 0; i < NVMA; i++) {
+       vma = &p->vmaslot[i];
+       // printf("%d-->begin:%d, length:%d, prot:%d, flags:%d, offset:%d, mapped:%d\n",i, vma->begin, vma->length, vma->prot, vma->flags, vma->offset, vma->mapped); 
+       if (vma->mapped && va >= vma->begin && va < vma->begin + vma->length) {
+          found = 1;
+          break;
+       }
+    }
+    if (found == 0) {
+       return -1;
+    }
+    if ((mem = kalloc()) == 0) {
+       return -1;
+    }   
+    memset(mem, 0, PGSIZE);
+    
+    //atomic
+    begin_op();
+    fptr = (struct file*)vma->f;
+    iptr = (struct inode*)fptr->ip;
+    ilock(iptr);
+    uint offset = vma->offset + PGROUNDDOWN(va - vma->begin);
+    readi(iptr, 0, (uint64)mem, offset , PGSIZE);
+    iunlock(iptr);
+    end_op();
+    int pteflag = PTE_U;
+    if (vma->prot & PROT_READ) {
+       pteflag |= PTE_R;
+    }
+    if (vma->prot & PROT_WRITE) {
+        pteflag |= PTE_W;
+    }
+    if (vma->prot & PROT_EXEC) {
+        pteflag |= PTE_X;
+    }
+    if (mappages(p->pagetable, va, PGSIZE, (uint64)mem, pteflag) != 0) {
+       kfree(mem);
+       return -1;
+    }
+    return 0;
+}
+
+
+uint64
+sys_mmap(void)
+{
+    uint64 length, offset, top;
+    int prot, flags, fd;
+    struct file *f;
+    struct proc *p;
+    struct vma *vma = 0, *tvma;
+    if (argaddr(1, &length) < 0 || argint(2, &prot) < 0 || argint(3, &flags) < 0 ||
+            argfd(4, &fd, &f) < 0 || argaddr(5, &offset) < 0) {
+        return -1;
+    }
+    if (length == 0) {
+        return -1;
+    }
+    if ((f->readable == 0 && (prot & (PROT_READ))) || (f->writable == 0 && (prot & (PROT_WRITE)) && (flags & (MAP_PRIVATE)) == 0)) {
+        return -1;
+    }
+    p = myproc();
+    top = TRAPFRAME;
+    int found = 0;
+    for (int i = 0; i < NVMA; i++) {
+        tvma = &p->vmaslot[i];
+        if (tvma->mapped == 1) {
+            if (tvma->begin < top) {
+                top = tvma->begin;
+                top = PGROUNDDOWN(top);
+            }
+        } else if (tvma->mapped == 0) {
+            if (!found) {
+                found = 1;
+                vma = tvma;
+                vma->mapped = 1;
+            }
+       // printf("%d-->begin:%d, length:%d, prot:%d, flags:%d, offset:%d, mapped:%d\n",i, vma->begin, vma->length, vma->prot, vma->flags, vma->offset, vma->mapped); 
+        }
+    }
+    if (found == 0 && vma == 0) {
+        return -1;
+    }  
+    length = PGROUNDUP(length);
+    vma->begin = top - length;
+    vma->length = length;
+    vma->prot = prot;
+    vma->flags = flags;
+    vma->offset = offset;
+    vma->f = f;
+    filedup(f);
+    
+    return vma->begin;
+}
+
+int
+fileuvmunmap(pagetable_t pagetable, uint64 va, uint64 bytes, struct vma* vma)
+{
+    pte_t *pte;
+    struct file* f;
+    for (uint64 i = va; i < va + bytes; i += PGSIZE) {
+       if ((pte = walk(pagetable, i, 0)) == 0) {
+          return -1;
+       }
+       if ((*pte) & PTE_V) {
+          if (((*pte) & PTE_D) && (vma->flags & MAP_SHARED)) {
+             // write back
+             f = vma->f;
+             uint64 writeoff = i - vma->begin;
+             if (writeoff < 0) {
+                filewrite(f, i, PGSIZE + writeoff);
+             } else if (writeoff + PGSIZE > vma->length) {
+                filewrite(f, i, vma->length - writeoff);
+             } else {
+                filewrite(f, i, PGSIZE);
+             }
+          }
+       }                                                                                        
+       uvmunmap(pagetable, i, 1, 1);
+       *pte = 0;
+    }
+    return 1;
+}
+
+
+uint64
+sys_munmap(void)
+{
+    struct proc *p = myproc();
+    uint64 va, length, tva;
+    struct vma *vma = 0, *tvma;
+    if (argaddr(0, &va) < 0 || argaddr(1, &length) < 0) {
+        return -1;
+    }
+    for (int i = 0; i < NVMA; i++) {
+        tvma = &p->vmaslot[i];
+        if (tvma->mapped && va >= tvma->begin && va < tvma->begin + tvma->length) {
+            vma = tvma;
+            break;
+        }
+    }
+    if (vma == 0) {
+        return -1;
+    }
+    // n munmap call might cover only a portion of an mmap-ed region, but you can assume that it will either unmap at the start, or at the end, or the whole region (but not punch a hole in the middle of a region). 
+    if (va > vma->begin && va + length < vma->begin + vma->length) {
+        return -1;
+    }
+    tva = va;
+    if (va > vma->begin) {
+        tva = PGROUNDDOWN(tva);
+    }
+    int n = length - (tva - va);
+    if (n < 0) {
+        return -1;
+    }
+    if (fileuvmunmap(p->pagetable, tva, (uint64)n, vma) < 0) {
+        return -1;
+    }
+    if (va <= vma->begin && va + length > vma->begin) {
+        uint64 dif = va + length - vma->begin;
+        vma->begin = va + length;
+        vma->offset = vma->offset + dif;
+    }
+    vma->length -= length;
+    if (vma->length <= 0) {
+        fileclose(vma->f);
+        vma->mapped = 0;
+    }
+    return 0;
+}
+
 uint64
 sys_write(void)
 {
@@ -88,6 +271,7 @@ sys_write(void)
   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argaddr(1, &p) < 0)
     return -1;
 
+
   return filewrite(f, p, n);
 }
 
diff --git a/kernel/trap.c b/kernel/trap.c
index a63249e..826fe08 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -29,6 +29,55 @@ trapinithart(void)
   w_stvec((uint64)kernelvec);
 }
 
+//int 
+//lazyallocation(uint64 va)
+//{
+//    struct proc *p = myproc();
+//    struct vma *vma;
+//    struct file *fptr;
+//    struct inode *iptr;
+//    int found = 0;
+//    char *mem;
+//    for (int i = 0; i < NVMA; i++) {
+//        vma = &p->vmaslot[i];
+//        if (vma->mapped && va >= vma->begin && va < vma->begin + vma->length) {
+//            found = 1;
+//            break;
+//        }
+//    }
+//    if (found == 0) {
+//        return -1;
+//    }
+//    if ((mem = kalloc()) == 0) {
+//        return -1;
+//    }   
+//    memset(mem, 0, PGSIZE);
+//    
+//    //atomic
+//    begin_op();
+//    fptr = (struct file*)vma->f;
+//    iptr = (struct file*)fptr->ip;
+//    ilock(iptr);
+//    readi(iptr, 0, (uint64)mem, offset, PGSIZE);
+//    iunlock(iptr);
+//    end_op();
+//    uint64 pteflag = PTE_U;
+//    if (vma->prot & PROT_READ) {
+//        pteflag |= PTE_R;        
+//    }
+//    if (vma->prot & PROT_WRITE) {
+//        pteflag |= PTE_W;
+//    }
+//    if (vma->prot & PROT_EXEC) {
+//        pteflag |= PTE_X;
+//    }
+//    if (mappages(p->pagetable, PGROUNDDOWN(va), PGSIZE, (uint64)mem, pteflag) != 0) {
+//        kfree(mem);
+//        return -1;
+//    }
+//    return 0;
+//}
+
 //
 // handle an interrupt, exception, or system call from user space.
 // called from trampoline.S
@@ -68,9 +117,20 @@ usertrap(void)
   } else if((which_dev = devintr()) != 0){
     // ok
   } else {
-    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
-    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
-    p->killed = 1;
+    uint64 va = r_stval();
+    uint64 nowscause = r_scause();
+    if (nowscause == 13 || nowscause == 15) {
+        // lazy allocation
+        if (lazyallocation(va) == -1) {
+            printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
+            printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
+            p->killed = 1;
+        }
+    } else {
+        printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
+        printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
+        p->killed = 1;
+    }
   }
 
   if(p->killed)
diff --git a/kernel/vm.c b/kernel/vm.c
index b47f111..75c4f5c 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -172,7 +172,8 @@ uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
     if((pte = walk(pagetable, a, 0)) == 0)
       panic("uvmunmap: walk");
     if((*pte & PTE_V) == 0)
-      panic("uvmunmap: not mapped");
+      // panic("uvmunmap: not mapped");
+      continue;
     if(PTE_FLAGS(*pte) == PTE_V)
       panic("uvmunmap: not a leaf");
     if(do_free){
@@ -183,6 +184,34 @@ uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
   }
 }
 
+// int
+// fileuvmunmap(pagetable_t pagetable, uint64 va, uint64 bytes, struct vma* vma) {
+//     pte_t *  continue;pte;
+//     struct file* f;
+//     for (uint64 i = va; i < va + bytes; i += PGSIZE) {
+//         if ((pte = walk(pagetable, i, 0)) == 0) {
+//             return -1;
+//         }
+//         if ((*pte) & PTE_V) {
+//             if (((*pte) & PTE_D) && (vma->flags & MAP_SHARED)) {
+//                 // write back
+//                 f = vma->f;
+//                 uint64 writeoff = i - vma->begin;
+//                 if (writeoff < 0) {
+//                     filewrite(f, i, PGSIZE + writeoff);
+//                 } else if (writeoff + PGSIZE > vma->length) {
+//                     filewrite(f, i, vma->length - writeoff);
+//                 } else {
+//                     filewrite(f, i, PGSIZE);
+//                 }
+//             }
+//         }
+//         uvmunmap(pagetable, i, 1, 1);
+//         *pte = 0;
+//     }
+//     return 1;
+// }
+
 // create an empty user page table.
 // returns 0 if out of memory.
 pagetable_t
@@ -306,7 +335,8 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
     if((pte = walk(old, i, 0)) == 0)
       panic("uvmcopy: pte should exist");
     if((*pte & PTE_V) == 0)
-      panic("uvmcopy: page not present");
+      // panic("uvmcopy: page not present");
+        continue;
     pa = PTE2PA(*pte);
     flags = PTE_FLAGS(*pte);
     if((mem = kalloc()) == 0)
diff --git a/time.txt b/time.txt
new file mode 100644
index 0000000..f599e28
--- /dev/null
+++ b/time.txt
@@ -0,0 +1 @@
+10
diff --git a/user/user.h b/user/user.h
index b71ecda..bc5cf66 100644
--- a/user/user.h
+++ b/user/user.h
@@ -23,6 +23,8 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+void* mmap(void*, uint64, int, int, int, uint64);
+int munmap(void*, uint64);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..d23b9cc 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,5 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("mmap");
+entry("munmap");
