diff --git a/Makefile b/Makefile
index d8509b1..6f7688c 100644
--- a/Makefile
+++ b/Makefile
@@ -175,7 +175,7 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
-
+	$U/_symlinktest\
 
 
 
diff --git a/kernel/fcntl.h b/kernel/fcntl.h
index 44861b9..5fb0896 100644
--- a/kernel/fcntl.h
+++ b/kernel/fcntl.h
@@ -1,5 +1,6 @@
-#define O_RDONLY  0x000
+#define O_RDONLY  0x000     
 #define O_WRONLY  0x001
 #define O_RDWR    0x002
 #define O_CREATE  0x200
 #define O_TRUNC   0x400
+#define O_NOFOLLOW  0x800   // 0010 0100 1000
diff --git a/kernel/file.h b/kernel/file.h
index b076d1d..559b7f8 100644
--- a/kernel/file.h
+++ b/kernel/file.h
@@ -26,7 +26,8 @@ struct inode {
   short minor;
   short nlink;
   uint size;
-  uint addrs[NDIRECT+1];
+  // uint addrs[NDIRECT+1];
+  uint addrs[NDIRECT+2];
 };
 
 // map major device number to device functions.
diff --git a/kernel/fs.c b/kernel/fs.c
index f33553a..971a28d 100644
--- a/kernel/fs.c
+++ b/kernel/fs.c
@@ -21,6 +21,7 @@
 #include "buf.h"
 #include "file.h"
 
+#define NDBINDIRECT (NINDIRECT * NINDIRECT)
 #define min(a, b) ((a) < (b) ? (a) : (b))
 // there should be one superblock per disk device, but we run with
 // only one device
@@ -374,68 +375,180 @@ iunlockput(struct inode *ip)
 
 // Return the disk block address of the nth block in inode ip.
 // If there is no such block, bmap allocates one.
+// static uint
+// bmap(struct inode *ip, uint bn)
+// {
+//   uint addr, *a;
+//   struct buf *bp;
+// 
+//   if(bn < NDIRECT){
+//     if((addr = ip->addrs[bn]) == 0)
+//       ip->addrs[bn] = addr = balloc(ip->dev);
+//     return addr;
+//   }
+//   bn -= NDIRECT;
+// 
+//   if(bn < NINDIRECT){
+//     // Load indirect block, allocating if necessary.
+//     if((addr = ip->addrs[NDIRECT]) == 0)
+//       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+//     bp = bread(ip->dev, addr);
+//     a = (uint*)bp->data;
+//     if((addr = a[bn]) == 0){
+//       a[bn] = addr = balloc(ip->dev);
+//       log_write(bp);
+//     }
+//     brelse(bp);
+//     return addr;
+//   }
+// 
+//   panic("bmap: out of range");
+// }
+
 static uint
-bmap(struct inode *ip, uint bn)
-{
-  uint addr, *a;
-  struct buf *bp;
+bmap(struct inode *ip, uint bn) {
+    uint addr, *a;
+    struct buf *bp;
+    if (bn < NDIRECT) {
+        if ((addr = ip->addrs[bn]) == 0) {
+            ip->addrs[bn] = addr = balloc(ip->dev);
+        }
+        return addr;
+    }
+    bn -= NDIRECT;
+    
+    if (bn < NINDIRECT) {
+        // Load indirect block, allocating if necessary.
+        if ((addr = ip->addrs[NDIRECT]) == 0) {
+            ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+        }
+        bp = bread(ip->dev, addr);
+        a = (uint*)bp->data;
+        if ((addr = a[bn]) == 0) {
+            a[bn] = addr = balloc(ip->dev);
+            log_write(bp);
+        }
+        brelse(bp);
+        return addr;
+    }
 
-  if(bn < NDIRECT){
-    if((addr = ip->addrs[bn]) == 0)
-      ip->addrs[bn] = addr = balloc(ip->dev);
-    return addr;
-  }
-  bn -= NDIRECT;
-
-  if(bn < NINDIRECT){
-    // Load indirect block, allocating if necessary.
-    if((addr = ip->addrs[NDIRECT]) == 0)
-      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
-    bp = bread(ip->dev, addr);
-    a = (uint*)bp->data;
-    if((addr = a[bn]) == 0){
-      a[bn] = addr = balloc(ip->dev);
-      log_write(bp);
+    
+    // doubly-indirect block
+
+    bn -= NINDIRECT;
+    if (bn < NDBINDIRECT) {
+        if ((addr = ip->addrs[NDIRECT + 1]) == 0) {
+            ip->addrs[NDIRECT + 1] = addr = balloc(ip->dev);
+        }
+        bp = bread(ip->dev, addr);
+        a = (uint*)bp->data;
+        int firstindex = bn / NINDIRECT;
+        if ((addr = a[firstindex]) == 0) {
+            a[firstindex] = addr = balloc(ip->dev);
+            log_write(bp);
+        }
+        brelse(bp);
+
+        bp = bread(ip->dev, addr);
+        a = (uint*)bp->data;
+        int secondindex = bn % NINDIRECT;
+        if ((addr = a[secondindex]) == 0) {
+            a[secondindex] = addr = balloc(ip->dev);
+            log_write(bp);
+        }
+        brelse(bp);
+        return addr;
     }
-    brelse(bp);
-    return addr;
-  }
 
-  panic("bmap: out of range");
+
+    panic("bmap: out of range");
 }
 
+
 // Truncate inode (discard contents).
 // Caller must hold ip->lock.
-void
-itrunc(struct inode *ip)
-{
-  int i, j;
-  struct buf *bp;
-  uint *a;
+// void
+// itrunc(struct inode *ip)
+// {
+//   int i, j;
+//   struct buf *bp;
+//   uint *a;
+// 
+//   for(i = 0; i < NDIRECT; i++){
+//     if(ip->addrs[i]){
+//       bfree(ip->dev, ip->addrs[i]);
+//       ip->addrs[i] = 0;
+//     }
+//   }
+// 
+//   if(ip->addrs[NDIRECT]){
+//     bp = bread(ip->dev, ip->addrs[NDIRECT]);
+//     a = (uint*)bp->data;
+//     for(j = 0; j < NINDIRECT; j++){
+//       if(a[j])
+//         bfree(ip->dev, a[j]);
+//     }
+//     brelse(bp);
+//     bfree(ip->dev, ip->addrs[NDIRECT]);
+//     ip->addrs[NDIRECT] = 0;
+//   }
+// 
+//   ip->size = 0;
+//   iupdate(ip);
+// }
 
-  for(i = 0; i < NDIRECT; i++){
-    if(ip->addrs[i]){
-      bfree(ip->dev, ip->addrs[i]);
-      ip->addrs[i] = 0;
+void
+itrunc(struct inode *ip) {
+    int i, j, k;
+    struct buf *bp, *secbp;
+    uint *a, *seca;
+    for (i = 0; i < NDIRECT; i++) {
+        if (ip->addrs[i]) {
+            bfree(ip->dev, ip->addrs[i]);
+            ip->addrs[i] = 0;
+        }
+    }
+    
+    if (ip->addrs[NDIRECT]) {
+        bp = bread(ip->dev, ip->addrs[NDIRECT]);
+        a = (uint*)bp->data;
+        for (j = 0; j < NINDIRECT; j++) {
+            if (a[j]) {
+                bfree(ip->dev, a[j]);
+            }
+        }
+        brelse(bp);
+        bfree(ip->dev, ip->addrs[NDIRECT]);
+        ip->addrs[NDIRECT] = 0;
     }
-  }
 
-  if(ip->addrs[NDIRECT]){
-    bp = bread(ip->dev, ip->addrs[NDIRECT]);
-    a = (uint*)bp->data;
-    for(j = 0; j < NINDIRECT; j++){
-      if(a[j])
-        bfree(ip->dev, a[j]);
+    // doubly indirect
+    if (ip->addrs[NDIRECT + 1]) {
+        bp = bread(ip->dev, ip->addrs[NDIRECT + 1]);
+        a = (uint*)bp->data;
+        for (j = 0; j < NINDIRECT; j++) {
+            if (a[j]) {
+                secbp = bread(ip->dev, a[j]);
+                seca = (uint*)secbp->data;
+                for (k = 0; k < NINDIRECT; k++) {
+                    if (seca[k]) {
+                        bfree(ip->dev, seca[k]);
+                    }
+                }
+                brelse(secbp);
+                bfree(ip->dev, a[j]);
+            }
+        }
+        brelse(bp);
+        bfree(ip->dev, ip->addrs[NDIRECT + 1]);
+        ip->addrs[NDIRECT + 1] = 0;
     }
-    brelse(bp);
-    bfree(ip->dev, ip->addrs[NDIRECT]);
-    ip->addrs[NDIRECT] = 0;
-  }
 
-  ip->size = 0;
-  iupdate(ip);
+    ip->size = 0;
+    iupdate(ip);
 }
 
+
 // Copy stat information from inode.
 // Caller must hold ip->lock.
 void
diff --git a/kernel/fs.h b/kernel/fs.h
index 139dcc9..0c2514e 100644
--- a/kernel/fs.h
+++ b/kernel/fs.h
@@ -24,9 +24,11 @@ struct superblock {
 
 #define FSMAGIC 0x10203040
 
-#define NDIRECT 12
+// #define NDIRECT 12
+#define NDIRECT 11
 #define NINDIRECT (BSIZE / sizeof(uint))
-#define MAXFILE (NDIRECT + NINDIRECT)
+#define NDBINDIRECT (NINDIRECT * NINDIRECT)
+#define MAXFILE (NDIRECT + NINDIRECT + NDBINDIRECT)
 
 // On-disk inode structure
 struct dinode {
@@ -35,7 +37,7 @@ struct dinode {
   short minor;          // Minor device number (T_DEVICE only)
   short nlink;          // Number of links to inode in file system
   uint size;            // Size of file (bytes)
-  uint addrs[NDIRECT+1];   // Data block addresses
+  uint addrs[NDIRECT+2];  // Data block addresses
 };
 
 // Inodes per block.
diff --git a/kernel/stat.h b/kernel/stat.h
index 19543af..55079e2 100644
--- a/kernel/stat.h
+++ b/kernel/stat.h
@@ -1,6 +1,7 @@
 #define T_DIR     1   // Directory
 #define T_FILE    2   // File
 #define T_DEVICE  3   // Device
+#define T_SYMLINK 4   // link
 
 struct stat {
   int dev;     // File system's disk device
diff --git a/kernel/syscall.c b/kernel/syscall.c
index c1b3670..1697b62 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -104,6 +104,7 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_wait(void);
 extern uint64 sys_write(void);
 extern uint64 sys_uptime(void);
+extern uint64 sys_symlink(void);
 
 static uint64 (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -127,6 +128,7 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_symlink] sys_symlink,
 };
 
 void
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..13818da 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,4 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_symlink 22
diff --git a/kernel/sysfile.c b/kernel/sysfile.c
index 5dc453b..d142168 100644
--- a/kernel/sysfile.c
+++ b/kernel/sysfile.c
@@ -52,6 +52,7 @@ fdalloc(struct file *f)
   return -1;
 }
 
+
 uint64
 sys_dup(void)
 {
@@ -73,7 +74,7 @@ sys_read(void)
   int n;
   uint64 p;
 
-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argaddr(1, &p) < 0)
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argaddr(1, &p) < 0) 
     return -1;
   return fileread(f, p, n);
 }
@@ -283,6 +284,30 @@ create(char *path, short type, short major, short minor)
   return ip;
 }
 
+uint64
+sys_symlink(void) {
+    struct inode *ip;
+    char path[MAXPATH], target[MAXPATH];
+    int pathlen;
+    if (argstr(0, target, MAXPATH) < 0 || argstr(1, path, MAXPATH) < 0) {
+        return -1;
+    }
+    begin_op();
+    if ((ip = create(path, T_SYMLINK, 0, 0)) == 0) {
+        end_op();
+        return -1;
+    }
+    pathlen = strlen(target);
+    if ((writei(ip, 0, (uint64)target, 0, pathlen) < 0)) {
+        end_op();
+        return -1;
+    }  
+    iunlockput(ip);
+    end_op();
+    return 0;
+
+}
+
 uint64
 sys_open(void)
 {
@@ -304,11 +329,40 @@ sys_open(void)
       return -1;
     }
   } else {
-    if((ip = namei(path)) == 0){
-      end_op();
-      return -1;
+    // if((ip = namei(path)) == 0){
+    //   end_op();
+    //   return -1;
+    // }
+    // ilock(ip);
+    
+    int depth = 0;
+    for ( ; ; ) {
+        if ((ip = namei(path)) == 0) {  // get inode
+            end_op();           
+            return -1;
+        }
+        ilock(ip);      // lock
+        if (ip->type == T_SYMLINK && (omode & O_NOFOLLOW) == 0) {    //T_SYMLINK and FOLLOW
+            // You may approximate this by returning an error code if the depth of links reaches some threshold (e.g., 10).
+            if (++depth > 10) {
+                iunlockput(ip);     // drop
+                end_op();
+                return -1;
+            }
+            if (readi(ip, 0, (uint64)path, 0, MAXPATH) < 0) {
+                iunlockput(ip);     //drop
+                end_op();
+                return -1;
+            }
+            iunlockput(ip);
+        } else {
+            // NO_FOLLOW OR NOT T_SYMLINK
+            break;
+        }
     }
-    ilock(ip);
+
+    //do.....
+    
     if(ip->type == T_DIR && omode != O_RDONLY){
       iunlockput(ip);
       end_op();
diff --git a/time.txt b/time.txt
new file mode 100644
index 0000000..f599e28
--- /dev/null
+++ b/time.txt
@@ -0,0 +1 @@
+10
diff --git a/user/user.h b/user/user.h
index b71ecda..ea0b006 100644
--- a/user/user.h
+++ b/user/user.h
@@ -23,6 +23,7 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int symlink(char*, char*);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..bc5c22e 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,4 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("symlink");
