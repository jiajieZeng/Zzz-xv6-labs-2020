diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index e8bcda9..1f8a600 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -43,12 +43,22 @@ sys_sbrk(void)
 {
   int addr;
   int n;
-
+  struct proc *p = myproc();
   if(argint(0, &n) < 0)
     return -1;
-  addr = myproc()->sz;
-  if(growproc(n) < 0)
-    return -1;
+  addr = p->sz;
+  // if(growproc(n) < 0)
+    // return -1;
+  // myproc()->sz = myproc()->sz + n;
+  if (n >= 0) {
+    p->sz = p->sz + n;
+  } else {
+    if (growproc(n) < 0) {
+        // return -1;
+        // p->killed = 1;
+        return -1;
+    }
+  }
   return addr;
 }
 
diff --git a/kernel/trap.c b/kernel/trap.c
index a63249e..0cc9d87 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -6,6 +6,7 @@
 #include "proc.h"
 #include "defs.h"
 
+
 struct spinlock tickslock;
 uint ticks;
 
@@ -67,6 +68,23 @@ usertrap(void)
     syscall();
   } else if((which_dev = devintr()) != 0){
     // ok
+  } else if (r_scause() == 13 || r_scause() == 15) {
+    uint64 va0 = r_stval();
+    if (va0 < p->trapframe->sp || va0 >= p->sz) {
+        p->killed =1;
+    } else {    
+        char *mem = kalloc();
+        if (mem == 0) {
+            p->killed = 1;
+        } else {
+            uint64 st = PGROUNDDOWN(va0);
+            memset(mem, 0, PGSIZE);
+            if (mappages(p->pagetable, st, PGSIZE, (uint64)mem, PTE_X | PTE_W | PTE_R | PTE_U) != 0) {
+                kfree(mem);
+                p->killed = 1;
+            }
+        }
+    }
   } else {
     printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
     printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
diff --git a/kernel/vm.c b/kernel/vm.c
index bccb405..7439558 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -5,6 +5,8 @@
 #include "riscv.h"
 #include "defs.h"
 #include "fs.h"
+#include "spinlock.h"
+#include "proc.h"
 
 /*
  * the kernel's page table.
@@ -180,10 +182,14 @@ uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
     panic("uvmunmap: not aligned");
 
   for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
-    if((pte = walk(pagetable, a, 0)) == 0)
-      panic("uvmunmap: walk");
-    if((*pte & PTE_V) == 0)
-      panic("uvmunmap: not mapped");
+    if((pte = walk(pagetable, a, 0)) == 0) {
+      // panic("uvmunmap: walk");
+      continue;
+    }
+    if((*pte & PTE_V) == 0) {
+      // panic("uvmunmap: not mapped");
+      continue;
+    }
     if(PTE_FLAGS(*pte) == PTE_V)
       panic("uvmunmap: not a leaf");
     if(do_free){
@@ -314,10 +320,14 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
   char *mem;
 
   for(i = 0; i < sz; i += PGSIZE){
-    if((pte = walk(old, i, 0)) == 0)
-      panic("uvmcopy: pte should exist");
-    if((*pte & PTE_V) == 0)
-      panic("uvmcopy: page not present");
+    if((pte = walk(old, i, 0)) == 0) {
+      // panic("uvmcopy: pte should exist");
+      continue;
+    }
+    if((*pte & PTE_V) == 0) {
+      // panic("uvmcopy: page not present");
+      continue;
+    }
     pa = PTE2PA(*pte);
     flags = PTE_FLAGS(*pte);
     if((mem = kalloc()) == 0)
@@ -355,12 +365,30 @@ int
 copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
 {
   uint64 n, va0, pa0;
-
+  struct proc *p = myproc();
   while(len > 0){
     va0 = PGROUNDDOWN(dstva);
     pa0 = walkaddr(pagetable, va0);
-    if(pa0 == 0)
-      return -1;
+    // if(pa0 == 0)
+      // return -1;
+    if (pa0 == 0) {
+        if (va0 >= p->sz || va0 < p->trapframe->sp) {
+            return -1;
+        } else {
+            // char *mem = kalloc();
+            pa0 = (uint64)kalloc();
+            if (pa0 == 0/*mem == 0*/) {
+                p->killed = 1;
+            } else {
+                va0 = PGROUNDDOWN(va0);
+                memset((void *)pa0, 0, PGSIZE);
+                if (mappages(p->pagetable, va0, PGSIZE, pa0, PTE_X | PTE_W | PTE_R | PTE_U) != 0) {
+                    kfree((void *)pa0);
+                    p->killed = 1;
+                }
+            }
+        }
+    }
     n = PGSIZE - (dstva - va0);
     if(n > len)
       n = len;
@@ -380,12 +408,30 @@ int
 copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
 {
   uint64 n, va0, pa0;
-
+  struct proc *p = myproc();
   while(len > 0){
     va0 = PGROUNDDOWN(srcva);
     pa0 = walkaddr(pagetable, va0);
-    if(pa0 == 0)
-      return -1;
+    // if(pa0 == 0)
+      // return -1;
+    if (pa0 == 0) {
+        if (va0 >= p->sz || va0 < p->trapframe->sp) {
+            return -1;
+        } else {
+            // char *mem = kalloc();
+            pa0 = (uint64)kalloc();
+            if (pa0 == 0/*mem == 0*/) {
+                p->killed = 1;
+            } else {
+                va0 = PGROUNDDOWN(va0);
+                memset((void *)pa0, 0, PGSIZE);
+                if (mappages(p->pagetable, va0, PGSIZE, pa0, PTE_X | PTE_W | PTE_R | PTE_U) != 0) {
+                    kfree((void *)pa0);
+                    p->killed = 1;
+                }
+            }
+        }
+    }
     n = PGSIZE - (srcva - va0);
     if(n > len)
       n = len;
diff --git a/time.txt b/time.txt
new file mode 100644
index 0000000..45a4fb7
--- /dev/null
+++ b/time.txt
@@ -0,0 +1 @@
+8
